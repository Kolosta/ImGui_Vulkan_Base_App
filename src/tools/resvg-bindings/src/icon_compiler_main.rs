use std::env;
use std::fs;
use std::path::Path;
use walkdir::WalkDir;
use usvg::Options;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 3 {
        eprintln!("Usage: icon_compiler <icons_dir> <output_header>");
        std::process::exit(1);
    }

    let icons_dir = Path::new(&args[1]);
    let output_header = Path::new(&args[2]);

    if !icons_dir.exists() {
        eprintln!("Icons directory does not exist: {:?}", icons_dir);
        std::process::exit(1);
    }

    let mut icons_data = Vec::new();

    // Walk through all SVG files
    for entry in WalkDir::new(icons_dir)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().and_then(|s| s.to_str()) == Some("svg"))
    {
        let path = entry.path();
        let icon_id = path.file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("unknown")
            .to_string();

        match collect_icon_data(path, &icon_id) {
            Ok(data) => icons_data.push(data),
            Err(e) => eprintln!("Warning: Failed to process {:?}: {}", path, e),
        }
    }

    // Generate C++ header
    generate_cpp_header(&icons_data, output_header).expect("Failed to write output header");
    println!("Generated icon data for {} icons", icons_data.len());
}

#[derive(Debug)]
struct IconData {
    id: String,
    svg_content: String,
    width: f32,
    height: f32,
}

fn collect_icon_data(path: &Path, icon_id: &str) -> Result<IconData, Box<dyn std::error::Error>> {
    let svg_content = fs::read_to_string(path)?;
    
    // Parse with usvg to get dimensions
    let opt = Options::default();
    let tree = usvg::Tree::from_str(&svg_content, &opt)?;
    let size = tree.size();

    Ok(IconData {
        id: icon_id.to_string(),
        svg_content,
        width: size.width(),
        height: size.height(),
    })
}

fn generate_cpp_header(icons: &[IconData], output_path: &Path) -> std::io::Result<()> {
    let mut cpp_code = String::new();

    cpp_code.push_str("// AUTO-GENERATED FILE - DO NOT EDIT\n");
    cpp_code.push_str("// Generated by icon_compiler\n\n");
    cpp_code.push_str("#pragma once\n\n");
    cpp_code.push_str("#include <string>\n");
    cpp_code.push_str("#include \"VectorGraphics/IconMetadata.h\"\n\n");
    cpp_code.push_str("namespace VectorGraphics {\n\n");

    // Generate CompiledIconData struct
    // cpp_code.push_str("struct CompiledIconData {\n");
    // cpp_code.push_str("    std::string id;\n");
    // cpp_code.push_str("    const char* svgContent;\n");
    // cpp_code.push_str("    float width;\n");
    // cpp_code.push_str("    float height;\n");
    // cpp_code.push_str("};\n\n");

    // Generate SVG content strings using raw string literals
    for icon in icons {
        let safe_id = icon.id.to_uppercase().replace('-', "_").replace("_ICON", "");
        cpp_code.push_str(&format!("static const char* ICON_SVG_{} = R\"svg(", safe_id));
        cpp_code.push_str(&icon.svg_content);
        cpp_code.push_str(")svg\";\n\n");
    }

    // Generate icon data array
    cpp_code.push_str("static const CompiledIconData COMPILED_ICONS[] = {\n");
    
    for icon in icons {
        let safe_id = icon.id.to_uppercase().replace('-', "_").replace("_ICON", "");
        cpp_code.push_str("    {\n");
        cpp_code.push_str(&format!("        \"{}\",\n", icon.id));
        cpp_code.push_str(&format!("        ICON_SVG_{},\n", safe_id));
        cpp_code.push_str(&format!("        {:.2}f,\n", icon.width));
        cpp_code.push_str(&format!("        {:.2}f\n", icon.height));
        cpp_code.push_str("    },\n");
    }
    
    cpp_code.push_str("};\n\n");
    cpp_code.push_str(&format!("static const size_t COMPILED_ICONS_COUNT = {};\n\n", icons.len()));
    cpp_code.push_str("} // namespace VectorGraphics\n");

    fs::write(output_path, cpp_code)?;
    Ok(())
}