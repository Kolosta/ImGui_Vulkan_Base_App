// // // // use std::env;
// // // // use std::fs;
// // // // use std::path::Path;
// // // // use walkdir::WalkDir;
// // // // use usvg::Options;

// // // // fn main() {
// // // //     let args: Vec<String> = env::args().collect();
// // // //     if args.len() != 3 {
// // // //         eprintln!("Usage: icon_compiler <icons_dir> <output_header>");
// // // //         std::process::exit(1);
// // // //     }

// // // //     let icons_dir = Path::new(&args[1]);
// // // //     let output_header = Path::new(&args[2]);

// // // //     if !icons_dir.exists() {
// // // //         eprintln!("Icons directory does not exist: {:?}", icons_dir);
// // // //         std::process::exit(1);
// // // //     }

// // // //     let mut icons_data = Vec::new();

// // // //     // Walk through all SVG files
// // // //     for entry in WalkDir::new(icons_dir)
// // // //         .into_iter()
// // // //         .filter_map(|e| e.ok())
// // // //         .filter(|e| e.path().extension().and_then(|s| s.to_str()) == Some("svg"))
// // // //     {
// // // //         let path = entry.path();
// // // //         let icon_id = path.file_stem()
// // // //             .and_then(|s| s.to_str())
// // // //             .unwrap_or("unknown")
// // // //             .to_string();

// // // //         match collect_icon_data(path, &icon_id) {
// // // //             Ok(data) => icons_data.push(data),
// // // //             Err(e) => eprintln!("Warning: Failed to process {:?}: {}", path, e),
// // // //         }
// // // //     }

// // // //     // Generate C++ header
// // // //     generate_cpp_header(&icons_data, output_header).expect("Failed to write output header");
// // // //     println!("Generated icon data for {} icons", icons_data.len());
// // // // }

// // // // #[derive(Debug)]
// // // // struct IconData {
// // // //     id: String,
// // // //     svg_content: String,
// // // //     width: f32,
// // // //     height: f32,
// // // // }

// // // // fn collect_icon_data(path: &Path, icon_id: &str) -> Result<IconData, Box<dyn std::error::Error>> {
// // // //     let svg_content = fs::read_to_string(path)?;
    
// // // //     // Parse with usvg to get dimensions
// // // //     let opt = Options::default();
// // // //     let tree = usvg::Tree::from_str(&svg_content, &opt)?;
// // // //     let size = tree.size();

// // // //     Ok(IconData {
// // // //         id: icon_id.to_string(),
// // // //         svg_content,
// // // //         width: size.width(),
// // // //         height: size.height(),
// // // //     })
// // // // }

// // // // fn generate_cpp_header(icons: &[IconData], output_path: &Path) -> std::io::Result<()> {
// // // //     let mut cpp_code = String::new();

// // // //     cpp_code.push_str("// AUTO-GENERATED FILE - DO NOT EDIT\n");
// // // //     cpp_code.push_str("// Generated by icon_compiler\n\n");
// // // //     cpp_code.push_str("#pragma once\n\n");
// // // //     cpp_code.push_str("#include <string>\n");
// // // //     cpp_code.push_str("#include \"VectorGraphics/IconMetadata.h\"\n\n");
// // // //     cpp_code.push_str("namespace VectorGraphics {\n\n");

// // // //     // Generate CompiledIconData struct
// // // //     // cpp_code.push_str("struct CompiledIconData {\n");
// // // //     // cpp_code.push_str("    std::string id;\n");
// // // //     // cpp_code.push_str("    const char* svgContent;\n");
// // // //     // cpp_code.push_str("    float width;\n");
// // // //     // cpp_code.push_str("    float height;\n");
// // // //     // cpp_code.push_str("};\n\n");

// // // //     // Generate SVG content strings using raw string literals
// // // //     for icon in icons {
// // // //         let safe_id = icon.id.to_uppercase().replace('-', "_").replace("_ICON", "");
// // // //         cpp_code.push_str(&format!("static const char* ICON_SVG_{} = R\"svg(", safe_id));
// // // //         cpp_code.push_str(&icon.svg_content);
// // // //         cpp_code.push_str(")svg\";\n\n");
// // // //     }

// // // //     // Generate icon data array
// // // //     cpp_code.push_str("static const CompiledIconData COMPILED_ICONS[] = {\n");
    
// // // //     for icon in icons {
// // // //         let safe_id = icon.id.to_uppercase().replace('-', "_").replace("_ICON", "");
// // // //         cpp_code.push_str("    {\n");
// // // //         cpp_code.push_str(&format!("        \"{}\",\n", icon.id));
// // // //         cpp_code.push_str(&format!("        ICON_SVG_{},\n", safe_id));
// // // //         cpp_code.push_str(&format!("        {:.2}f,\n", icon.width));
// // // //         cpp_code.push_str(&format!("        {:.2}f\n", icon.height));
// // // //         cpp_code.push_str("    },\n");
// // // //     }
    
// // // //     cpp_code.push_str("};\n\n");
// // // //     cpp_code.push_str(&format!("static const size_t COMPILED_ICONS_COUNT = {};\n\n", icons.len()));
// // // //     cpp_code.push_str("} // namespace VectorGraphics\n");

// // // //     fs::write(output_path, cpp_code)?;
// // // //     Ok(())
// // // // }





// // // use roxmltree::{Document, Node, ParsingOptions};
// // // use std::collections::{HashMap, HashSet};
// // // use std::fs;
// // // use std::path::{Path, PathBuf};

// // // mod color_parser;
// // // use color_parser::parse_color;

// // // #[derive(Debug, Clone)]
// // // struct ColorMapping {
// // //     element_id: String,
// // //     property: String,
// // //     original_color: u32,
// // //     css_class: String,
// // // }

// // // #[derive(Debug, Clone)]
// // // struct ColorZone {
// // //     original_color: u32,
// // //     default_token: String,
// // //     mapping_indices: Vec<usize>,
// // // }

// // // #[derive(Debug)]
// // // struct IconData {
// // //     id: String,
// // //     svg_content: String,
// // //     width: f32,
// // //     height: f32,
// // //     color_mappings: Vec<ColorMapping>,
// // //     color_zones: Vec<ColorZone>,
// // // }

// // // fn extract_viewbox_dimensions(svg_content: &str) -> (f32, f32) {
// // //     // Parse with DTD support enabled
// // //     let opt = ParsingOptions {
// // //         allow_dtd: true,
// // //         ..Default::default()
// // //     };
    
// // //     if let Ok(doc) = Document::parse_with_options(svg_content, opt) {
// // //         if let Some(svg_elem) = doc.root_element().children().find(|n| n.has_tag_name("svg")) {
// // //             // Try viewBox first
// // //             if let Some(viewbox) = svg_elem.attribute("viewBox") {
// // //                 let parts: Vec<&str> = viewbox.split_whitespace().collect();
// // //                 if parts.len() == 4 {
// // //                     if let (Ok(w), Ok(h)) = (parts[2].parse::<f32>(), parts[3].parse::<f32>()) {
// // //                         return (w, h);
// // //                     }
// // //                 }
// // //             }
            
// // //             // Fallback to width/height attributes
// // //             if let (Some(w_str), Some(h_str)) = (svg_elem.attribute("width"), svg_elem.attribute("height")) {
// // //                 let w = w_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
// // //                 let h = h_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
// // //                 return (w, h);
// // //             }
// // //         } else if doc.root_element().has_tag_name("svg") {
// // //             // SVG is the root element
// // //             let svg_elem = doc.root_element();
            
// // //             if let Some(viewbox) = svg_elem.attribute("viewBox") {
// // //                 let parts: Vec<&str> = viewbox.split_whitespace().collect();
// // //                 if parts.len() == 4 {
// // //                     if let (Ok(w), Ok(h)) = (parts[2].parse::<f32>(), parts[3].parse::<f32>()) {
// // //                         return (w, h);
// // //                     }
// // //                 }
// // //             }
            
// // //             if let (Some(w_str), Some(h_str)) = (svg_elem.attribute("width"), svg_elem.attribute("height")) {
// // //                 let w = w_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
// // //                 let h = h_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
// // //                 return (w, h);
// // //             }
// // //         }
// // //     }
    
// // //     (24.0, 24.0) // Default fallback
// // // }

// // // fn parse_style_attribute(style: &str) -> HashMap<String, String> {
// // //     let mut properties = HashMap::new();
    
// // //     for property in style.split(';') {
// // //         let parts: Vec<&str> = property.split(':').collect();
// // //         if parts.len() == 2 {
// // //             let key = parts[0].trim().to_string();
// // //             let value = parts[1].trim().to_string();
// // //             properties.insert(key, value);
// // //         }
// // //     }
    
// // //     properties
// // // }

// // // fn extract_color_mappings(svg_content: &str) -> Result<Vec<ColorMapping>, String> {
// // //     let opt = ParsingOptions {
// // //         allow_dtd: true,
// // //         ..Default::default()
// // //     };
    
// // //     let doc = Document::parse_with_options(svg_content, opt)
// // //         .map_err(|e| format!("{}", e))?;
    
// // //     let mut mappings = Vec::new();
// // //     let mut element_counter = 0;
    
// // //     fn traverse_node(
// // //         node: Node,
// // //         mappings: &mut Vec<ColorMapping>,
// // //         element_counter: &mut usize,
// // //     ) {
// // //         if node.is_element() {
// // //             *element_counter += 1;
// // //             let element_id = format!("elem_{}", element_counter);
            
// // //             // Get CSS class if present
// // //             let css_class = node.attribute("class").unwrap_or("").to_string();
            
// // //             // Check fill attribute
// // //             if let Some(fill_value) = node.attribute("fill") {
// // //                 if fill_value != "none" && !fill_value.starts_with("url(") {
// // //                     if let Some(color) = parse_color(fill_value) {
// // //                         mappings.push(ColorMapping {
// // //                             element_id: element_id.clone(),
// // //                             property: "fill".to_string(),
// // //                             original_color: color,
// // //                             css_class: css_class.clone(),
// // //                         });
// // //                     }
// // //                 }
// // //             }
            
// // //             // Check stroke attribute
// // //             if let Some(stroke_value) = node.attribute("stroke") {
// // //                 if stroke_value != "none" && !stroke_value.starts_with("url(") {
// // //                     if let Some(color) = parse_color(stroke_value) {
// // //                         mappings.push(ColorMapping {
// // //                             element_id: element_id.clone(),
// // //                             property: "stroke".to_string(),
// // //                             original_color: color,
// // //                             css_class: css_class.clone(),
// // //                         });
// // //                     }
// // //                 }
// // //             }
            
// // //             // Check stop-color attribute (for gradients)
// // //             if let Some(stop_color) = node.attribute("stop-color") {
// // //                 if stop_color != "none" && !stop_color.starts_with("url(") {
// // //                     if let Some(color) = parse_color(stop_color) {
// // //                         mappings.push(ColorMapping {
// // //                             element_id: element_id.clone(),
// // //                             property: "stop-color".to_string(),
// // //                             original_color: color,
// // //                             css_class: css_class.clone(),
// // //                         });
// // //                     }
// // //                 }
// // //             }
            
// // //             // Parse style attribute
// // //             if let Some(style_attr) = node.attribute("style") {
// // //                 let style_properties = parse_style_attribute(style_attr);
                
// // //                 if let Some(fill_value) = style_properties.get("fill") {
// // //                     if fill_value != "none" && !fill_value.starts_with("url(") {
// // //                         if let Some(color) = parse_color(fill_value) {
// // //                             mappings.push(ColorMapping {
// // //                                 element_id: element_id.clone(),
// // //                                 property: "fill".to_string(),
// // //                                 original_color: color,
// // //                                 css_class: css_class.clone(),
// // //                             });
// // //                         }
// // //                     }
// // //                 }
                
// // //                 if let Some(stroke_value) = style_properties.get("stroke") {
// // //                     if stroke_value != "none" && !stroke_value.starts_with("url(") {
// // //                         if let Some(color) = parse_color(stroke_value) {
// // //                             mappings.push(ColorMapping {
// // //                                 element_id: element_id.clone(),
// // //                                 property: "stroke".to_string(),
// // //                                 original_color: color,
// // //                                 css_class: css_class.clone(),
// // //                             });
// // //                         }
// // //                     }
// // //                 }
                
// // //                 if let Some(stop_color) = style_properties.get("stop-color") {
// // //                     if stop_color != "none" && !stop_color.starts_with("url(") {
// // //                         if let Some(color) = parse_color(stop_color) {
// // //                             mappings.push(ColorMapping {
// // //                                 element_id: element_id.clone(),
// // //                                 property: "stop-color".to_string(),
// // //                                 original_color: color,
// // //                                 css_class: css_class.clone(),
// // //                             });
// // //                         }
// // //                     }
// // //                 }
// // //             }
// // //         }
        
// // //         for child in node.children() {
// // //             traverse_node(child, mappings, element_counter);
// // //         }
// // //     }
    
// // //     traverse_node(doc.root(), &mut mappings, &mut element_counter);
    
// // //     Ok(mappings)
// // // }

// // // fn determine_default_token(css_class: &str) -> String {
// // //     if css_class.contains("primary") {
// // //         "primary".to_string()
// // //     } else if css_class.contains("secondary") {
// // //         "secondary".to_string()
// // //     } else if css_class.contains("accent") {
// // //         "accent".to_string()
// // //     } else {
// // //         "primary".to_string()
// // //     }
// // // }

// // // fn build_color_zones(mappings: &[ColorMapping]) -> Vec<ColorZone> {
// // //     let mut color_map: HashMap<u32, Vec<(usize, String)>> = HashMap::new();
    
// // //     for (idx, mapping) in mappings.iter().enumerate() {
// // //         color_map
// // //             .entry(mapping.original_color)
// // //             .or_insert_with(Vec::new)
// // //             .push((idx, mapping.css_class.clone()));
// // //     }
    
// // //     let mut zones = Vec::new();
    
// // //     for (color, indices_and_classes) in color_map {
// // //         let default_token = if let Some((_, first_class)) = indices_and_classes.first() {
// // //             determine_default_token(first_class)
// // //         } else {
// // //             "primary".to_string()
// // //         };
        
// // //         let indices: Vec<usize> = indices_and_classes.iter().map(|(idx, _)| *idx).collect();
        
// // //         zones.push(ColorZone {
// // //             original_color: color,
// // //             default_token,
// // //             mapping_indices: indices,
// // //         });
// // //     }
    
// // //     zones.sort_by_key(|z| z.original_color);
// // //     zones
// // // }

// // // fn process_icon(icon_path: &Path) -> Result<IconData, String> {
// // //     let svg_content = fs::read_to_string(icon_path)
// // //         .map_err(|e| format!("Failed to read file: {}", e))?;
    
// // //     let (width, height) = extract_viewbox_dimensions(&svg_content);
    
// // //     let color_mappings = extract_color_mappings(&svg_content)?;
    
// // //     let color_zones = build_color_zones(&color_mappings);
    
// // //     let icon_name = icon_path
// // //         .file_stem()
// // //         .unwrap()
// // //         .to_string_lossy()
// // //         .to_string();
    
// // //     Ok(IconData {
// // //         id: icon_name,
// // //         svg_content,
// // //         width,
// // //         height,
// // //         color_mappings,
// // //         color_zones,
// // //     })
// // // }

// // // fn sanitize_identifier(name: &str) -> String {
// // //     name.chars()
// // //         .map(|c| if c.is_alphanumeric() || c == '_' { c } else { '_' })
// // //         .collect::<String>()
// // //         .to_uppercase()
// // // }

// // // fn generate_header_file(icons: &[IconData], output_path: &Path) -> std::io::Result<()> {
// // //     let mut output = String::new();
    
// // //     output.push_str("// AUTO-GENERATED FILE - DO NOT EDIT\n");
// // //     output.push_str("// Generated by icon_compiler\n\n");
// // //     output.push_str("#pragma once\n\n");
// // //     output.push_str("#include \"VectorGraphics/IconMetadata.h\"\n\n");
// // //     output.push_str("namespace VectorGraphics {\n\n");
    
// // //     // Generate SVG content constants
// // //     for icon in icons {
// // //         let const_name = format!("ICON_SVG_{}", sanitize_identifier(&icon.id));
// // //         output.push_str(&format!("static const char* {} = R\"svg({})svg\";\n\n", const_name, icon.svg_content));
// // //     }
    
// // //     // Generate color mappings arrays
// // //     for icon in icons {
// // //         if !icon.color_mappings.is_empty() {
// // //             let array_name = format!("ICON_MAPPINGS_{}", sanitize_identifier(&icon.id));
// // //             output.push_str(&format!("static const CompiledColorMapping {}[] = {{\n", array_name));
            
// // //             for mapping in &icon.color_mappings {
// // //                 output.push_str("    {\n");
// // //                 output.push_str(&format!("        \"{}\",\n", mapping.element_id));
// // //                 output.push_str(&format!("        \"{}\",\n", mapping.property));
// // //                 output.push_str(&format!("        0x{:08X}u,\n", mapping.original_color));
// // //                 output.push_str(&format!("        \"{}\"\n", mapping.css_class));
// // //                 output.push_str("    },\n");
// // //             }
            
// // //             output.push_str("};\n\n");
// // //         }
// // //     }
    
// // //     // Generate zone index arrays
// // //     for icon in icons {
// // //         for (zone_idx, zone) in icon.color_zones.iter().enumerate() {
// // //             let array_name = format!(
// // //                 "ICON_ZONE_{}_INDICES_{}",
// // //                 sanitize_identifier(&icon.id),
// // //                 zone_idx
// // //             );
// // //             output.push_str(&format!("static const size_t {}[] = {{ ", array_name));
            
// // //             for (i, idx) in zone.mapping_indices.iter().enumerate() {
// // //                 if i > 0 {
// // //                     output.push_str(", ");
// // //                 }
// // //                 output.push_str(&format!("{}", idx));
// // //             }
            
// // //             output.push_str(" };\n");
// // //         }
        
// // //         if !icon.color_zones.is_empty() {
// // //             output.push_str("\n");
// // //         }
// // //     }
    
// // //     // Generate color zones arrays
// // //     for icon in icons {
// // //         if !icon.color_zones.is_empty() {
// // //             let array_name = format!("ICON_ZONES_{}", sanitize_identifier(&icon.id));
// // //             output.push_str(&format!("static const CompiledColorZone {}[] = {{\n", array_name));
            
// // //             for (zone_idx, zone) in icon.color_zones.iter().enumerate() {
// // //                 let indices_array = format!(
// // //                     "ICON_ZONE_{}_INDICES_{}",
// // //                     sanitize_identifier(&icon.id),
// // //                     zone_idx
// // //                 );
                
// // //                 output.push_str("    {\n");
// // //                 output.push_str(&format!("        0x{:08X}u,\n", zone.original_color));
// // //                 output.push_str(&format!("        \"{}\",\n", zone.default_token));
// // //                 output.push_str(&format!("        {},\n", indices_array));
// // //                 output.push_str(&format!("        {}\n", zone.mapping_indices.len()));
// // //                 output.push_str("    },\n");
// // //             }
            
// // //             output.push_str("};\n\n");
// // //         }
// // //     }
    
// // //     // Generate main icons array
// // //     output.push_str("static const CompiledIconData COMPILED_ICONS[] = {\n");
    
// // //     for (_icon_idx, icon) in icons.iter().enumerate() {
// // //         let svg_const = format!("ICON_SVG_{}", sanitize_identifier(&icon.id));
// // //         let mappings_const = if !icon.color_mappings.is_empty() {
// // //             format!("ICON_MAPPINGS_{}", sanitize_identifier(&icon.id))
// // //         } else {
// // //             "nullptr".to_string()
// // //         };
// // //         let zones_const = if !icon.color_zones.is_empty() {
// // //             format!("ICON_ZONES_{}", sanitize_identifier(&icon.id))
// // //         } else {
// // //             "nullptr".to_string()
// // //         };
        
// // //         output.push_str("    {\n");
// // //         output.push_str(&format!("        \"{}\",\n", icon.id));
// // //         output.push_str(&format!("        {},\n", svg_const));
// // //         output.push_str(&format!("        {:.2}f,\n", icon.width));
// // //         output.push_str(&format!("        {:.2}f,\n", icon.height));
// // //         output.push_str(&format!("        {},\n", mappings_const));
// // //         output.push_str(&format!("        {},\n", icon.color_mappings.len()));
// // //         output.push_str(&format!("        {},\n", zones_const));
// // //         output.push_str(&format!("        {}\n", icon.color_zones.len()));
// // //         output.push_str("    },\n");
// // //     }
    
// // //     output.push_str("};\n\n");
// // //     output.push_str(&format!("static const size_t COMPILED_ICONS_COUNT = {};\n\n", icons.len()));
// // //     output.push_str("} // namespace VectorGraphics\n");
    
// // //     fs::write(output_path, output)
// // // }

// // // fn find_svg_files(dir: &Path) -> Vec<PathBuf> {
// // //     let mut svg_files = Vec::new();
    
// // //     if dir.is_dir() {
// // //         if let Ok(entries) = fs::read_dir(dir) {
// // //             for entry in entries.flatten() {
// // //                 let path = entry.path();
// // //                 if path.is_dir() {
// // //                     svg_files.extend(find_svg_files(&path));
// // //                 } else if path.extension().and_then(|s| s.to_str()) == Some("svg") {
// // //                     svg_files.push(path);
// // //                 }
// // //             }
// // //         }
// // //     }
    
// // //     svg_files
// // // }

// // // fn main() {
// // //     let args: Vec<String> = std::env::args().collect();
    
// // //     if args.len() != 3 {
// // //         eprintln!("Usage: icon_compiler <icons_directory> <output_header>");
// // //         std::process::exit(1);
// // //     }
    
// // //     let icons_dir = Path::new(&args[1]);
// // //     let output_file = Path::new(&args[2]);
    
// // //     if !icons_dir.exists() {
// // //         eprintln!("Error: Icons directory does not exist: {:?}", icons_dir);
// // //         std::process::exit(1);
// // //     }
    
// // //     let svg_files = find_svg_files(icons_dir);
    
// // //     if svg_files.is_empty() {
// // //         eprintln!("Warning: No SVG files found in {:?}", icons_dir);
// // //         std::process::exit(0);
// // //     }
    
// // //     let mut icons = Vec::new();
    
// // //     for svg_path in svg_files {
// // //         match process_icon(&svg_path) {
// // //             Ok(icon_data) => {
// // //                 println!("Processed {}: {} colors detected", 
// // //                     icon_data.id, 
// // //                     icon_data.color_mappings.len()
// // //                 );
// // //                 icons.push(icon_data);
// // //             }
// // //             Err(e) => {
// // //                 eprintln!("Warning: Failed to process \"{}\": {}", 
// // //                     svg_path.display(), 
// // //                     e
// // //                 );
// // //             }
// // //         }
// // //     }
    
// // //     if icons.is_empty() {
// // //         eprintln!("Error: No icons were successfully processed");
// // //         std::process::exit(1);
// // //     }
    
// // //     if let Err(e) = generate_header_file(&icons, output_file) {
// // //         eprintln!("Error: Failed to generate header file: {}", e);
// // //         std::process::exit(1);
// // //     }
    
// // //     println!("Generated icon data for {} icons", icons.len());
// // // }






// // use roxmltree::{Document, ParsingOptions};
// // use std::collections::HashMap;
// // use std::fs;
// // use std::path::{Path, PathBuf};

// // mod color_parser;
// // use color_parser::parse_color;

// // #[derive(Debug, Clone)]
// // struct ColorMapping {
// //     element_id: String,
// //     property: String,
// //     original_color: u32,
// //     css_class: String,
// // }

// // #[derive(Debug, Clone)]
// // struct ColorZone {
// //     original_color: u32,
// //     default_token: String,
// //     mapping_indices: Vec<usize>,
// // }

// // #[derive(Debug)]
// // struct IconData {
// //     id: String,
// //     svg_content: String,
// //     width: f32,
// //     height: f32,
// //     color_mappings: Vec<ColorMapping>,
// //     color_zones: Vec<ColorZone>,
// // }

// // fn extract_viewbox_dimensions(svg_content: &str) -> (f32, f32) {
// //     // Parse with DTD support enabled
// //     let opt = ParsingOptions {
// //         allow_dtd: true,
// //         ..Default::default()
// //     };
    
// //     if let Ok(doc) = Document::parse_with_options(svg_content, opt) {
// //         if let Some(svg_elem) = doc.root_element().children().find(|n| n.has_tag_name("svg")) {
// //             // Try viewBox first
// //             if let Some(viewbox) = svg_elem.attribute("viewBox") {
// //                 let parts: Vec<&str> = viewbox.split_whitespace().collect();
// //                 if parts.len() == 4 {
// //                     if let (Ok(w), Ok(h)) = (parts[2].parse::<f32>(), parts[3].parse::<f32>()) {
// //                         return (w, h);
// //                     }
// //                 }
// //             }
            
// //             // Fallback to width/height attributes
// //             if let (Some(w_str), Some(h_str)) = (svg_elem.attribute("width"), svg_elem.attribute("height")) {
// //                 let w = w_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
// //                 let h = h_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
// //                 return (w, h);
// //             }
// //         } else if doc.root_element().has_tag_name("svg") {
// //             // SVG is the root element
// //             let svg_elem = doc.root_element();
            
// //             if let Some(viewbox) = svg_elem.attribute("viewBox") {
// //                 let parts: Vec<&str> = viewbox.split_whitespace().collect();
// //                 if parts.len() == 4 {
// //                     if let (Ok(w), Ok(h)) = (parts[2].parse::<f32>(), parts[3].parse::<f32>()) {
// //                         return (w, h);
// //                     }
// //                 }
// //             }
            
// //             if let (Some(w_str), Some(h_str)) = (svg_elem.attribute("width"), svg_elem.attribute("height")) {
// //                 let w = w_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
// //                 let h = h_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
// //                 return (w, h);
// //             }
// //         }
// //     }
    
// //     (24.0, 24.0) // Default fallback
// // }

// // fn parse_style_attribute(style: &str) -> HashMap<String, String> {
// //     let mut properties = HashMap::new();
    
// //     for property in style.split(';') {
// //         let parts: Vec<&str> = property.split(':').collect();
// //         if parts.len() == 2 {
// //             let key = parts[0].trim().to_string();
// //             let value = parts[1].trim().to_string();
// //             properties.insert(key, value);
// //         }
// //     }
    
// //     properties
// // }

// // fn extract_color_mappings(svg_content: &str) -> Result<Vec<ColorMapping>, String> {
// //     let opt = ParsingOptions {
// //         allow_dtd: true,
// //         ..Default::default()
// //     };
    
// //     let doc = Document::parse_with_options(svg_content, opt)
// //         .map_err(|e| format!("{}", e))?;
    
// //     let mut mappings = Vec::new();
// //     let mut element_counter = 0;
    
// //     fn traverse_node(
// //         node: roxmltree::Node,
// //         mappings: &mut Vec<ColorMapping>,
// //         element_counter: &mut usize,
// //     ) {
// //         if node.is_element() {
// //             *element_counter += 1;
// //             let element_id = format!("elem_{}", element_counter);
            
// //             // Get CSS class if present
// //             let css_class = node.attribute("class").unwrap_or("").to_string();
            
// //             // Check fill attribute
// //             if let Some(fill_value) = node.attribute("fill") {
// //                 if fill_value != "none" && !fill_value.starts_with("url(") {
// //                     if let Some(color) = parse_color(fill_value) {
// //                         mappings.push(ColorMapping {
// //                             element_id: element_id.clone(),
// //                             property: "fill".to_string(),
// //                             original_color: color,
// //                             css_class: css_class.clone(),
// //                         });
// //                     }
// //                 }
// //             }
            
// //             // Check stroke attribute
// //             if let Some(stroke_value) = node.attribute("stroke") {
// //                 if stroke_value != "none" && !stroke_value.starts_with("url(") {
// //                     if let Some(color) = parse_color(stroke_value) {
// //                         mappings.push(ColorMapping {
// //                             element_id: element_id.clone(),
// //                             property: "stroke".to_string(),
// //                             original_color: color,
// //                             css_class: css_class.clone(),
// //                         });
// //                     }
// //                 }
// //             }
            
// //             // Check stop-color attribute (for gradients)
// //             if let Some(stop_color) = node.attribute("stop-color") {
// //                 if stop_color != "none" && !stop_color.starts_with("url(") {
// //                     if let Some(color) = parse_color(stop_color) {
// //                         mappings.push(ColorMapping {
// //                             element_id: element_id.clone(),
// //                             property: "stop-color".to_string(),
// //                             original_color: color,
// //                             css_class: css_class.clone(),
// //                         });
// //                     }
// //                 }
// //             }
            
// //             // Parse style attribute
// //             if let Some(style_attr) = node.attribute("style") {
// //                 let style_properties = parse_style_attribute(style_attr);
                
// //                 if let Some(fill_value) = style_properties.get("fill") {
// //                     if fill_value != "none" && !fill_value.starts_with("url(") {
// //                         if let Some(color) = parse_color(fill_value) {
// //                             mappings.push(ColorMapping {
// //                                 element_id: element_id.clone(),
// //                                 property: "fill".to_string(),
// //                                 original_color: color,
// //                                 css_class: css_class.clone(),
// //                             });
// //                         }
// //                     }
// //                 }
                
// //                 if let Some(stroke_value) = style_properties.get("stroke") {
// //                     if stroke_value != "none" && !stroke_value.starts_with("url(") {
// //                         if let Some(color) = parse_color(stroke_value) {
// //                             mappings.push(ColorMapping {
// //                                 element_id: element_id.clone(),
// //                                 property: "stroke".to_string(),
// //                                 original_color: color,
// //                                 css_class: css_class.clone(),
// //                             });
// //                         }
// //                     }
// //                 }
                
// //                 if let Some(stop_color) = style_properties.get("stop-color") {
// //                     if stop_color != "none" && !stop_color.starts_with("url(") {
// //                         if let Some(color) = parse_color(stop_color) {
// //                             mappings.push(ColorMapping {
// //                                 element_id: element_id.clone(),
// //                                 property: "stop-color".to_string(),
// //                                 original_color: color,
// //                                 css_class: css_class.clone(),
// //                             });
// //                         }
// //                     }
// //                 }
// //             }
// //         }
        
// //         for child in node.children() {
// //             traverse_node(child, mappings, element_counter);
// //         }
// //     }
    
// //     traverse_node(doc.root(), &mut mappings, &mut element_counter);
    
// //     Ok(mappings)
// // }

// // fn determine_default_token(css_class: &str) -> String {
// //     if css_class.contains("primary") {
// //         "primary".to_string()
// //     } else if css_class.contains("secondary") {
// //         "secondary".to_string()
// //     } else if css_class.contains("accent") {
// //         "accent".to_string()
// //     } else {
// //         "primary".to_string()
// //     }
// // }

// // fn build_color_zones(mappings: &[ColorMapping]) -> Vec<ColorZone> {
// //     let mut color_map: HashMap<u32, Vec<(usize, String)>> = HashMap::new();
    
// //     for (idx, mapping) in mappings.iter().enumerate() {
// //         color_map
// //             .entry(mapping.original_color)
// //             .or_insert_with(Vec::new)
// //             .push((idx, mapping.css_class.clone()));
// //     }
    
// //     let mut zones = Vec::new();
    
// //     for (color, indices_and_classes) in color_map {
// //         let default_token = if let Some((_, first_class)) = indices_and_classes.first() {
// //             determine_default_token(first_class)
// //         } else {
// //             "primary".to_string()
// //         };
        
// //         let indices: Vec<usize> = indices_and_classes.iter().map(|(idx, _)| *idx).collect();
        
// //         zones.push(ColorZone {
// //             original_color: color,
// //             default_token,
// //             mapping_indices: indices,
// //         });
// //     }
    
// //     zones.sort_by_key(|z| z.original_color);
// //     zones
// // }

// // fn process_icon(icon_path: &Path) -> Result<IconData, String> {
// //     let svg_content = fs::read_to_string(icon_path)
// //         .map_err(|e| format!("Failed to read file: {}", e))?;
    
// //     let (width, height) = extract_viewbox_dimensions(&svg_content);
    
// //     let color_mappings = extract_color_mappings(&svg_content)?;
    
// //     let color_zones = build_color_zones(&color_mappings);
    
// //     let icon_name = icon_path
// //         .file_stem()
// //         .unwrap()
// //         .to_string_lossy()
// //         .to_string();
    
// //     Ok(IconData {
// //         id: icon_name,
// //         svg_content,
// //         width,
// //         height,
// //         color_mappings,
// //         color_zones,
// //     })
// // }

// // fn sanitize_identifier(name: &str) -> String {
// //     name.chars()
// //         .map(|c| if c.is_alphanumeric() || c == '_' { c } else { '_' })
// //         .collect::<String>()
// //         .to_uppercase()
// // }

// // fn generate_header_file(icons: &[IconData], output_path: &Path) -> std::io::Result<()> {
// //     let mut output = String::new();
    
// //     output.push_str("// AUTO-GENERATED FILE - DO NOT EDIT\n");
// //     output.push_str("// Generated by icon_compiler\n\n");
// //     output.push_str("#pragma once\n\n");
// //     output.push_str("#include \"VectorGraphics/IconMetadata.h\"\n\n");
// //     output.push_str("namespace VectorGraphics {\n\n");
    
// //     // Generate SVG content constants
// //     for icon in icons {
// //         let const_name = format!("ICON_SVG_{}", sanitize_identifier(&icon.id));
// //         output.push_str(&format!("static const char* {} = R\"svg({})svg\";\n\n", const_name, icon.svg_content));
// //     }
    
// //     // Generate color mappings arrays
// //     for icon in icons {
// //         if !icon.color_mappings.is_empty() {
// //             let array_name = format!("ICON_MAPPINGS_{}", sanitize_identifier(&icon.id));
// //             output.push_str(&format!("static const CompiledColorMapping {}[] = {{\n", array_name));
            
// //             for mapping in &icon.color_mappings {
// //                 output.push_str("    {\n");
// //                 output.push_str(&format!("        \"{}\",\n", mapping.element_id));
// //                 output.push_str(&format!("        \"{}\",\n", mapping.property));
// //                 output.push_str(&format!("        0x{:08X}u,\n", mapping.original_color));
// //                 output.push_str(&format!("        \"{}\"\n", mapping.css_class));
// //                 output.push_str("    },\n");
// //             }
            
// //             output.push_str("};\n\n");
// //         }
// //     }
    
// //     // Generate zone index arrays
// //     for icon in icons {
// //         for (zone_idx, zone) in icon.color_zones.iter().enumerate() {
// //             let array_name = format!(
// //                 "ICON_ZONE_{}_INDICES_{}",
// //                 sanitize_identifier(&icon.id),
// //                 zone_idx
// //             );
// //             output.push_str(&format!("static const size_t {}[] = {{ ", array_name));
            
// //             for (i, idx) in zone.mapping_indices.iter().enumerate() {
// //                 if i > 0 {
// //                     output.push_str(", ");
// //                 }
// //                 output.push_str(&format!("{}", idx));
// //             }
            
// //             output.push_str(" };\n");
// //         }
        
// //         if !icon.color_zones.is_empty() {
// //             output.push_str("\n");
// //         }
// //     }
    
// //     // Generate color zones arrays
// //     for icon in icons {
// //         if !icon.color_zones.is_empty() {
// //             let array_name = format!("ICON_ZONES_{}", sanitize_identifier(&icon.id));
// //             output.push_str(&format!("static const CompiledColorZone {}[] = {{\n", array_name));
            
// //             for (zone_idx, zone) in icon.color_zones.iter().enumerate() {
// //                 let indices_array = format!(
// //                     "ICON_ZONE_{}_INDICES_{}",
// //                     sanitize_identifier(&icon.id),
// //                     zone_idx
// //                 );
                
// //                 output.push_str("    {\n");
// //                 output.push_str(&format!("        0x{:08X}u,\n", zone.original_color));
// //                 output.push_str(&format!("        \"{}\",\n", zone.default_token));
// //                 output.push_str(&format!("        {},\n", indices_array));
// //                 output.push_str(&format!("        {}\n", zone.mapping_indices.len()));
// //                 output.push_str("    },\n");
// //             }
            
// //             output.push_str("};\n\n");
// //         }
// //     }
    
// //     // Generate main icons array
// //     output.push_str("static const CompiledIconData COMPILED_ICONS[] = {\n");
    
// //     for icon in icons.iter() {
// //         let svg_const = format!("ICON_SVG_{}", sanitize_identifier(&icon.id));
// //         let mappings_const = if !icon.color_mappings.is_empty() {
// //             format!("ICON_MAPPINGS_{}", sanitize_identifier(&icon.id))
// //         } else {
// //             "nullptr".to_string()
// //         };
// //         let zones_const = if !icon.color_zones.is_empty() {
// //             format!("ICON_ZONES_{}", sanitize_identifier(&icon.id))
// //         } else {
// //             "nullptr".to_string()
// //         };
        
// //         output.push_str("    {\n");
// //         output.push_str(&format!("        \"{}\",\n", icon.id));
// //         output.push_str(&format!("        {},\n", svg_const));
// //         output.push_str(&format!("        {:.2}f,\n", icon.width));
// //         output.push_str(&format!("        {:.2}f,\n", icon.height));
// //         output.push_str(&format!("        {},\n", mappings_const));
// //         output.push_str(&format!("        {},\n", icon.color_mappings.len()));
// //         output.push_str(&format!("        {},\n", zones_const));
// //         output.push_str(&format!("        {}\n", icon.color_zones.len()));
// //         output.push_str("    },\n");
// //     }
    
// //     output.push_str("};\n\n");
// //     output.push_str(&format!("static const size_t COMPILED_ICONS_COUNT = {};\n\n", icons.len()));
// //     output.push_str("} // namespace VectorGraphics\n");
    
// //     fs::write(output_path, output)
// // }

// // fn find_svg_files(dir: &Path) -> Vec<PathBuf> {
// //     let mut svg_files = Vec::new();
    
// //     if dir.is_dir() {
// //         if let Ok(entries) = fs::read_dir(dir) {
// //             for entry in entries.flatten() {
// //                 let path = entry.path();
// //                 if path.is_dir() {
// //                     svg_files.extend(find_svg_files(&path));
// //                 } else if path.extension().and_then(|s| s.to_str()) == Some("svg") {
// //                     svg_files.push(path);
// //                 }
// //             }
// //         }
// //     }
    
// //     svg_files
// // }

// // fn main() {
// //     let args: Vec<String> = std::env::args().collect();
    
// //     if args.len() != 3 {
// //         eprintln!("Usage: icon_compiler <icons_directory> <output_header>");
// //         std::process::exit(1);
// //     }
    
// //     let icons_dir = Path::new(&args[1]);
// //     let output_file = Path::new(&args[2]);
    
// //     if !icons_dir.exists() {
// //         eprintln!("Error: Icons directory does not exist: {:?}", icons_dir);
// //         std::process::exit(1);
// //     }
    
// //     let svg_files = find_svg_files(icons_dir);
    
// //     if svg_files.is_empty() {
// //         eprintln!("Warning: No SVG files found in {:?}", icons_dir);
// //         std::process::exit(0);
// //     }
    
// //     let mut icons = Vec::new();
    
// //     for svg_path in svg_files {
// //         match process_icon(&svg_path) {
// //             Ok(icon_data) => {
// //                 println!("Processed {}: {} colors detected", 
// //                     icon_data.id, 
// //                     icon_data.color_mappings.len()
// //                 );
// //                 icons.push(icon_data);
// //             }
// //             Err(e) => {
// //                 eprintln!("Warning: Failed to process \"{}\": {}", 
// //                     svg_path.display(), 
// //                     e
// //                 );
// //             }
// //         }
// //     }
    
// //     if icons.is_empty() {
// //         eprintln!("Error: No icons were successfully processed");
// //         std::process::exit(1);
// //     }
    
// //     if let Err(e) = generate_header_file(&icons, output_file) {
// //         eprintln!("Error: Failed to generate header file: {}", e);
// //         std::process::exit(1);
// //     }
    
// //     println!("Generated icon data for {} icons", icons.len());
// // }




// use std::collections::HashMap;
// use std::fs;
// use std::path::{Path, PathBuf};
// use roxmltree::{Document, ParsingOptions};

// mod color_parser;
// use color_parser::parse_color;

// #[derive(Debug, Clone)]
// struct ColorMapping {
//     element_id: String,
//     property: String,
//     original_color: u32,
//     css_class: String,
// }

// #[derive(Debug, Clone)]
// struct ColorZone {
//     original_color: u32,
//     default_token: String,
//     mapping_indices: Vec<usize>,
// }

// #[derive(Debug)]
// struct IconData {
//     id: String,
//     svg_content: String,
//     width: f32,
//     height: f32,
//     color_mappings: Vec<ColorMapping>,
//     color_zones: Vec<ColorZone>,
// }

// fn extract_viewbox_dimensions(svg_content: &str) -> (f32, f32) {
//     let opt = ParsingOptions {
//         allow_dtd: true,
//         ..Default::default()
//     };
    
//     if let Ok(doc) = Document::parse_with_options(svg_content, opt) {
//         if let Some(svg_elem) = doc.root_element().children().find(|n| n.has_tag_name("svg")) {
//             if let Some(viewbox) = svg_elem.attribute("viewBox") {
//                 let parts: Vec<&str> = viewbox.split_whitespace().collect();
//                 if parts.len() == 4 {
//                     if let (Ok(w), Ok(h)) = (parts[2].parse::<f32>(), parts[3].parse::<f32>()) {
//                         return (w, h);
//                     }
//                 }
//             }
            
//             if let (Some(w_str), Some(h_str)) = (svg_elem.attribute("width"), svg_elem.attribute("height")) {
//                 let w = w_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
//                 let h = h_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
//                 return (w, h);
//             }
//         } else if doc.root_element().has_tag_name("svg") {
//             let svg_elem = doc.root_element();
            
//             if let Some(viewbox) = svg_elem.attribute("viewBox") {
//                 let parts: Vec<&str> = viewbox.split_whitespace().collect();
//                 if parts.len() == 4 {
//                     if let (Ok(w), Ok(h)) = (parts[2].parse::<f32>(), parts[3].parse::<f32>()) {
//                         return (w, h);
//                     }
//                 }
//             }
            
//             if let (Some(w_str), Some(h_str)) = (svg_elem.attribute("width"), svg_elem.attribute("height")) {
//                 let w = w_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
//                 let h = h_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
//                 return (w, h);
//             }
//         }
//     }
    
//     (24.0, 24.0)
// }

// fn parse_style_attribute(style: &str) -> HashMap<String, String> {
//     let mut properties = HashMap::new();
    
//     for property in style.split(';') {
//         let parts: Vec<&str> = property.split(':').collect();
//         if parts.len() == 2 {
//             let key = parts[0].trim().to_string();
//             let value = parts[1].trim().to_string();
//             properties.insert(key, value);
//         }
//     }
    
//     properties
// }

// fn extract_color_mappings(svg_content: &str) -> Result<Vec<ColorMapping>, String> {
//     let opt = ParsingOptions {
//         allow_dtd: true,
//         ..Default::default()
//     };
    
//     let doc = Document::parse_with_options(svg_content, opt)
//         .map_err(|e| format!("{}", e))?;
    
//     let mut mappings = Vec::new();
//     let mut element_counter = 0;
    
//     fn traverse_node(
//         node: roxmltree::Node,
//         mappings: &mut Vec<ColorMapping>,
//         element_counter: &mut usize,
//     ) {
//         if node.is_element() {
//             *element_counter += 1;
//             let element_id = format!("elem_{}", element_counter);
            
//             let css_class = node.attribute("class").unwrap_or("").to_string();
            
//             if let Some(fill_value) = node.attribute("fill") {
//                 if fill_value != "none" && !fill_value.starts_with("url(") {
//                     if let Some(color) = parse_color(fill_value) {
//                         mappings.push(ColorMapping {
//                             element_id: element_id.clone(),
//                             property: "fill".to_string(),
//                             original_color: color,
//                             css_class: css_class.clone(),
//                         });
//                     }
//                 }
//             }
            
//             if let Some(stroke_value) = node.attribute("stroke") {
//                 if stroke_value != "none" && !stroke_value.starts_with("url(") {
//                     if let Some(color) = parse_color(stroke_value) {
//                         mappings.push(ColorMapping {
//                             element_id: element_id.clone(),
//                             property: "stroke".to_string(),
//                             original_color: color,
//                             css_class: css_class.clone(),
//                         });
//                     }
//                 }
//             }
            
//             if let Some(stop_color) = node.attribute("stop-color") {
//                 if stop_color != "none" && !stop_color.starts_with("url(") {
//                     if let Some(color) = parse_color(stop_color) {
//                         mappings.push(ColorMapping {
//                             element_id: element_id.clone(),
//                             property: "stop-color".to_string(),
//                             original_color: color,
//                             css_class: css_class.clone(),
//                         });
//                     }
//                 }
//             }
            
//             if let Some(style_attr) = node.attribute("style") {
//                 let style_properties = parse_style_attribute(style_attr);
                
//                 if let Some(fill_value) = style_properties.get("fill") {
//                     if fill_value != "none" && !fill_value.starts_with("url(") {
//                         if let Some(color) = parse_color(fill_value) {
//                             mappings.push(ColorMapping {
//                                 element_id: element_id.clone(),
//                                 property: "fill".to_string(),
//                                 original_color: color,
//                                 css_class: css_class.clone(),
//                             });
//                         }
//                     }
//                 }
                
//                 if let Some(stroke_value) = style_properties.get("stroke") {
//                     if stroke_value != "none" && !stroke_value.starts_with("url(") {
//                         if let Some(color) = parse_color(stroke_value) {
//                             mappings.push(ColorMapping {
//                                 element_id: element_id.clone(),
//                                 property: "stroke".to_string(),
//                                 original_color: color,
//                                 css_class: css_class.clone(),
//                             });
//                         }
//                     }
//                 }
                
//                 if let Some(stop_color) = style_properties.get("stop-color") {
//                     if stop_color != "none" && !stop_color.starts_with("url(") {
//                         if let Some(color) = parse_color(stop_color) {
//                             mappings.push(ColorMapping {
//                                 element_id: element_id.clone(),
//                                 property: "stop-color".to_string(),
//                                 original_color: color,
//                                 css_class: css_class.clone(),
//                             });
//                         }
//                     }
//                 }
//             }
//         }
        
//         for child in node.children() {
//             traverse_node(child, mappings, element_counter);
//         }
//     }
    
//     traverse_node(doc.root(), &mut mappings, &mut element_counter);
    
//     Ok(mappings)
// }

// fn determine_default_token(css_class: &str) -> String {
//     if css_class.contains("primary") || css_class.contains("ds-primary") {
//         "primary".to_string()
//     } else if css_class.contains("secondary") || css_class.contains("ds-secondary") {
//         "secondary".to_string()
//     } else if css_class.contains("tertiary") || css_class.contains("ds-tertiary") {
//         "tertiary".to_string()
//     } else if css_class.contains("accent") {
//         "accent".to_string()
//     } else {
//         "primary".to_string()
//     }
// }

// fn build_color_zones(mappings: &[ColorMapping]) -> Vec<ColorZone> {
//     let mut color_map: HashMap<u32, Vec<(usize, String)>> = HashMap::new();
    
//     for (idx, mapping) in mappings.iter().enumerate() {
//         color_map
//             .entry(mapping.original_color)
//             .or_insert_with(Vec::new)
//             .push((idx, mapping.css_class.clone()));
//     }
    
//     let mut zones = Vec::new();
    
//     for (color, indices_and_classes) in color_map {
//         let default_token = if let Some((_, first_class)) = indices_and_classes.first() {
//             determine_default_token(first_class)
//         } else {
//             "primary".to_string()
//         };
        
//         let indices: Vec<usize> = indices_and_classes.iter().map(|(idx, _)| *idx).collect();
        
//         zones.push(ColorZone {
//             original_color: color,
//             default_token,
//             mapping_indices: indices,
//         });
//     }
    
//     zones.sort_by_key(|z| z.original_color);
//     zones
// }

// fn process_icon(icon_path: &Path) -> Result<IconData, String> {
//     let svg_content = fs::read_to_string(icon_path)
//         .map_err(|e| format!("Failed to read file: {}", e))?;
    
//     let (width, height) = extract_viewbox_dimensions(&svg_content);
    
//     let color_mappings = extract_color_mappings(&svg_content)?;
    
//     let color_zones = build_color_zones(&color_mappings);
    
//     let icon_name = icon_path
//         .file_stem()
//         .unwrap()
//         .to_string_lossy()
//         .to_string();
    
//     Ok(IconData {
//         id: icon_name,
//         svg_content,
//         width,
//         height,
//         color_mappings,
//         color_zones,
//     })
// }

// fn sanitize_identifier(name: &str) -> String {
//     name.chars()
//         .map(|c| if c.is_alphanumeric() || c == '_' { c } else { '_' })
//         .collect::<String>()
//         .to_uppercase()
// }

// fn generate_header_file(icons: &[IconData], output_path: &Path) -> std::io::Result<()> {
//     let mut output = String::new();
    
//     output.push_str("// AUTO-GENERATED FILE - DO NOT EDIT\n");
//     output.push_str("// Generated by icon_compiler\n\n");
//     output.push_str("#pragma once\n\n");
//     output.push_str("#include \"VectorGraphics/IconMetadata.h\"\n\n");
//     output.push_str("namespace VectorGraphics {\n\n");
    
//     // Generate SVG content constants
//     for icon in icons {
//         let const_name = format!("ICON_SVG_{}", sanitize_identifier(&icon.id));
//         output.push_str(&format!("static const char* {} = R\"svg({})svg\";\n\n", const_name, icon.svg_content));
//     }
    
//     // Generate color mappings arrays
//     for icon in icons {
//         if !icon.color_mappings.is_empty() {
//             let array_name = format!("ICON_MAPPINGS_{}", sanitize_identifier(&icon.id));
//             output.push_str(&format!("static const CompiledColorMapping {}[] = {{\n", array_name));
            
//             for mapping in &icon.color_mappings {
//                 output.push_str("    {\n");
//                 output.push_str(&format!("        \"{}\",\n", mapping.element_id));
//                 output.push_str(&format!("        \"{}\",\n", mapping.property));
//                 output.push_str(&format!("        0x{:08X}u,\n", mapping.original_color));
//                 output.push_str(&format!("        \"{}\"\n", mapping.css_class));
//                 output.push_str("    },\n");
//             }
            
//             output.push_str("};\n\n");
//         }
//     }
    
//     // Generate zone index arrays
//     for icon in icons {
//         for (zone_idx, zone) in icon.color_zones.iter().enumerate() {
//             let array_name = format!(
//                 "ICON_ZONE_{}_INDICES_{}",
//                 sanitize_identifier(&icon.id),
//                 zone_idx
//             );
//             output.push_str(&format!("static const size_t {}[] = {{ ", array_name));
            
//             for (i, idx) in zone.mapping_indices.iter().enumerate() {
//                 if i > 0 {
//                     output.push_str(", ");
//                 }
//                 output.push_str(&format!("{}", idx));
//             }
            
//             output.push_str(" };\n");
//         }
        
//         if !icon.color_zones.is_empty() {
//             output.push_str("\n");
//         }
//     }
    
//     // Generate color zones arrays
//     for icon in icons {
//         if !icon.color_zones.is_empty() {
//             let array_name = format!("ICON_ZONES_{}", sanitize_identifier(&icon.id));
//             output.push_str(&format!("static const CompiledColorZone {}[] = {{\n", array_name));
            
//             for (zone_idx, zone) in icon.color_zones.iter().enumerate() {
//                 let indices_array = format!(
//                     "ICON_ZONE_{}_INDICES_{}",
//                     sanitize_identifier(&icon.id),
//                     zone_idx
//                 );
                
//                 output.push_str("    {\n");
//                 output.push_str(&format!("        0x{:08X}u,\n", zone.original_color));
//                 output.push_str(&format!("        \"{}\",\n", zone.default_token));
//                 output.push_str(&format!("        {},\n", indices_array));
//                 output.push_str(&format!("        {}\n", zone.mapping_indices.len()));
//                 output.push_str("    },\n");
//             }
            
//             output.push_str("};\n\n");
//         }
//     }
    
//     // Generate main icons array
//     output.push_str("static const CompiledIconData COMPILED_ICONS[] = {\n");
    
//     for icon in icons.iter() {
//         let svg_const = format!("ICON_SVG_{}", sanitize_identifier(&icon.id));
//         let mappings_const = if !icon.color_mappings.is_empty() {
//             format!("ICON_MAPPINGS_{}", sanitize_identifier(&icon.id))
//         } else {
//             "nullptr".to_string()
//         };
//         let zones_const = if !icon.color_zones.is_empty() {
//             format!("ICON_ZONES_{}", sanitize_identifier(&icon.id))
//         } else {
//             "nullptr".to_string()
//         };
        
//         output.push_str("    {\n");
//         output.push_str(&format!("        \"{}\",\n", icon.id));
//         output.push_str(&format!("        {},\n", svg_const));
//         output.push_str(&format!("        {:.2}f,\n", icon.width));
//         output.push_str(&format!("        {:.2}f,\n", icon.height));
//         output.push_str(&format!("        {},\n", mappings_const));
//         output.push_str(&format!("        {},\n", icon.color_mappings.len()));
//         output.push_str(&format!("        {},\n", zones_const));
//         output.push_str(&format!("        {}\n", icon.color_zones.len()));
//         output.push_str("    },\n");
//     }
    
//     output.push_str("};\n\n");
//     output.push_str(&format!("static const size_t COMPILED_ICONS_COUNT = {};\n\n", icons.len()));
//     output.push_str("} // namespace VectorGraphics\n");
    
//     fs::write(output_path, output)
// }

// fn find_svg_files(dir: &Path) -> Vec<PathBuf> {
//     let mut svg_files = Vec::new();
    
//     if dir.is_dir() {
//         if let Ok(entries) = fs::read_dir(dir) {
//             for entry in entries.flatten() {
//                 let path = entry.path();
//                 if path.is_dir() {
//                     svg_files.extend(find_svg_files(&path));
//                 } else if path.extension().and_then(|s| s.to_str()) == Some("svg") {
//                     svg_files.push(path);
//                 }
//             }
//         }
//     }
    
//     svg_files
// }

// fn main() {
//     let args: Vec<String> = std::env::args().collect();
    
//     if args.len() != 3 {
//         eprintln!("Usage: icon_compiler <icons_directory> <output_header>");
//         std::process::exit(1);
//     }
    
//     let icons_dir = Path::new(&args[1]);
//     let output_file = Path::new(&args[2]);
    
//     if !icons_dir.exists() {
//         eprintln!("Error: Icons directory does not exist: {:?}", icons_dir);
//         std::process::exit(1);
//     }
    
//     let svg_files = find_svg_files(icons_dir);
    
//     if svg_files.is_empty() {
//         eprintln!("Warning: No SVG files found in {:?}", icons_dir);
//         std::process::exit(0);
//     }
    
//     let mut icons = Vec::new();
    
//     for svg_path in svg_files {
//         match process_icon(&svg_path) {
//             Ok(icon_data) => {
//                 println!("Processed {}: {} colors detected", 
//                     icon_data.id, 
//                     icon_data.color_mappings.len()
//                 );
//                 icons.push(icon_data);
//             }
//             Err(e) => {
//                 eprintln!("Warning: Failed to process \"{}\": {}", 
//                     svg_path.display(), 
//                     e
//                 );
//             }
//         }
//     }
    
//     if icons.is_empty() {
//         eprintln!("Error: No icons were successfully processed");
//         std::process::exit(1);
//     }
    
//     if let Err(e) = generate_header_file(&icons, output_file) {
//         eprintln!("Error: Failed to generate header file: {}", e);
//         std::process::exit(1);
//     }
    
//     println!("Generated icon data for {} icons", icons.len());
// }







use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use roxmltree::{Document, ParsingOptions};

mod color_parser;
use color_parser::parse_color;

#[derive(Debug, Clone)]
struct ColorMapping {
    element_id: String,
    property: String,
    original_color: u32,
    css_class: String,
}

#[derive(Debug, Clone)]
struct ColorZone {
    original_color: u32,
    default_token: String,
    mapping_indices: Vec<usize>,
}

#[derive(Debug)]
struct IconData {
    id: String,
    svg_content: String,
    width: f32,
    height: f32,
    color_mappings: Vec<ColorMapping>,
    color_zones: Vec<ColorZone>,
}

fn extract_viewbox_dimensions(svg_content: &str) -> (f32, f32) {
    let opt = ParsingOptions {
        allow_dtd: true,
        ..Default::default()
    };
    
    if let Ok(doc) = Document::parse_with_options(svg_content, opt) {
        if let Some(svg_elem) = doc.root_element().children().find(|n| n.has_tag_name("svg")) {
            if let Some(viewbox) = svg_elem.attribute("viewBox") {
                let parts: Vec<&str> = viewbox.split_whitespace().collect();
                if parts.len() == 4 {
                    if let (Ok(w), Ok(h)) = (parts[2].parse::<f32>(), parts[3].parse::<f32>()) {
                        return (w, h);
                    }
                }
            }
            
            if let (Some(w_str), Some(h_str)) = (svg_elem.attribute("width"), svg_elem.attribute("height")) {
                let w = w_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
                let h = h_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
                return (w, h);
            }
        } else if doc.root_element().has_tag_name("svg") {
            let svg_elem = doc.root_element();
            
            if let Some(viewbox) = svg_elem.attribute("viewBox") {
                let parts: Vec<&str> = viewbox.split_whitespace().collect();
                if parts.len() == 4 {
                    if let (Ok(w), Ok(h)) = (parts[2].parse::<f32>(), parts[3].parse::<f32>()) {
                        return (w, h);
                    }
                }
            }
            
            if let (Some(w_str), Some(h_str)) = (svg_elem.attribute("width"), svg_elem.attribute("height")) {
                let w = w_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
                let h = h_str.trim_end_matches("px").parse::<f32>().unwrap_or(24.0);
                return (w, h);
            }
        }
    }
    
    (24.0, 24.0)
}

fn parse_style_attribute(style: &str) -> HashMap<String, String> {
    let mut properties = HashMap::new();
    
    for property in style.split(';') {
        let parts: Vec<&str> = property.split(':').collect();
        if parts.len() == 2 {
            let key = parts[0].trim().to_string();
            let value = parts[1].trim().to_string();
            properties.insert(key, value);
        }
    }
    
    properties
}

fn extract_color_mappings(svg_content: &str) -> Result<Vec<ColorMapping>, String> {
    let opt = ParsingOptions {
        allow_dtd: true,
        ..Default::default()
    };
    
    let doc = Document::parse_with_options(svg_content, opt)
        .map_err(|e| format!("{}", e))?;
    
    let mut mappings = Vec::new();
    let mut element_counter = 0;
    
    fn traverse_node(
        node: roxmltree::Node,
        mappings: &mut Vec<ColorMapping>,
        element_counter: &mut usize,
    ) {
        if node.is_element() {
            *element_counter += 1;
            let element_id = format!("elem_{}", element_counter);
            
            let css_class = node.attribute("class").unwrap_or("").to_string();
            
            if let Some(fill_value) = node.attribute("fill") {
                if fill_value != "none" && !fill_value.starts_with("url(") {
                    if let Some(color) = parse_color(fill_value) {
                        mappings.push(ColorMapping {
                            element_id: element_id.clone(),
                            property: "fill".to_string(),
                            original_color: color,
                            css_class: css_class.clone(),
                        });
                    }
                }
            }
            
            if let Some(stroke_value) = node.attribute("stroke") {
                if stroke_value != "none" && !stroke_value.starts_with("url(") {
                    if let Some(color) = parse_color(stroke_value) {
                        mappings.push(ColorMapping {
                            element_id: element_id.clone(),
                            property: "stroke".to_string(),
                            original_color: color,
                            css_class: css_class.clone(),
                        });
                    }
                }
            }
            
            if let Some(stop_color) = node.attribute("stop-color") {
                if stop_color != "none" && !stop_color.starts_with("url(") {
                    if let Some(color) = parse_color(stop_color) {
                        mappings.push(ColorMapping {
                            element_id: element_id.clone(),
                            property: "stop-color".to_string(),
                            original_color: color,
                            css_class: css_class.clone(),
                        });
                    }
                }
            }
            
            if let Some(style_attr) = node.attribute("style") {
                let style_properties = parse_style_attribute(style_attr);
                
                if let Some(fill_value) = style_properties.get("fill") {
                    if fill_value != "none" && !fill_value.starts_with("url(") {
                        if let Some(color) = parse_color(fill_value) {
                            mappings.push(ColorMapping {
                                element_id: element_id.clone(),
                                property: "fill".to_string(),
                                original_color: color,
                                css_class: css_class.clone(),
                            });
                        }
                    }
                }
                
                if let Some(stroke_value) = style_properties.get("stroke") {
                    if stroke_value != "none" && !stroke_value.starts_with("url(") {
                        if let Some(color) = parse_color(stroke_value) {
                            mappings.push(ColorMapping {
                                element_id: element_id.clone(),
                                property: "stroke".to_string(),
                                original_color: color,
                                css_class: css_class.clone(),
                            });
                        }
                    }
                }
                
                if let Some(stop_color) = style_properties.get("stop-color") {
                    if stop_color != "none" && !stop_color.starts_with("url(") {
                        if let Some(color) = parse_color(stop_color) {
                            mappings.push(ColorMapping {
                                element_id: element_id.clone(),
                                property: "stop-color".to_string(),
                                original_color: color,
                                css_class: css_class.clone(),
                            });
                        }
                    }
                }
            }
        }
        
        for child in node.children() {
            traverse_node(child, mappings, element_counter);
        }
    }
    
    traverse_node(doc.root(), &mut mappings, &mut element_counter);
    
    Ok(mappings)
}

fn determine_default_token(css_class: &str) -> String {
    if css_class.contains("primary") || css_class.contains("ds-primary") {
        "primary".to_string()
    } else if css_class.contains("secondary") || css_class.contains("ds-secondary") {
        "secondary".to_string()
    } else if css_class.contains("tertiary") || css_class.contains("ds-tertiary") {
        "tertiary".to_string()
    } else if css_class.contains("accent") {
        "accent".to_string()
    } else {
        "primary".to_string()
    }
}

fn build_color_zones(mappings: &[ColorMapping]) -> Vec<ColorZone> {
    let mut color_map: HashMap<u32, Vec<(usize, String)>> = HashMap::new();
    
    for (idx, mapping) in mappings.iter().enumerate() {
        color_map
            .entry(mapping.original_color)
            .or_insert_with(Vec::new)
            .push((idx, mapping.css_class.clone()));
    }
    
    let mut zones = Vec::new();
    
    for (color, indices_and_classes) in color_map {
        let default_token = if let Some((_, first_class)) = indices_and_classes.first() {
            determine_default_token(first_class)
        } else {
            "primary".to_string()
        };
        
        let indices: Vec<usize> = indices_and_classes.iter().map(|(idx, _)| *idx).collect();
        
        zones.push(ColorZone {
            original_color: color,
            default_token,
            mapping_indices: indices,
        });
    }
    
    zones.sort_by_key(|z| z.original_color);
    zones
}

fn process_icon(icon_path: &Path) -> Result<IconData, String> {
    let svg_content = fs::read_to_string(icon_path)
        .map_err(|e| format!("Failed to read file: {}", e))?;
    
    let (width, height) = extract_viewbox_dimensions(&svg_content);
    
    let color_mappings = extract_color_mappings(&svg_content)?;
    
    let color_zones = build_color_zones(&color_mappings);
    
    let icon_name = icon_path
        .file_stem()
        .unwrap()
        .to_string_lossy()
        .to_string();
    
    Ok(IconData {
        id: icon_name,
        svg_content,
        width,
        height,
        color_mappings,
        color_zones,
    })
}

fn sanitize_identifier(name: &str) -> String {
    name.chars()
        .map(|c| if c.is_alphanumeric() || c == '_' { c } else { '_' })
        .collect::<String>()
        .to_uppercase()
}

fn generate_header_file(icons: &[IconData], output_path: &Path) -> std::io::Result<()> {
    let mut output = String::new();
    
    output.push_str("// AUTO-GENERATED FILE - DO NOT EDIT\n");
    output.push_str("// Generated by icon_compiler\n\n");
    output.push_str("#pragma once\n\n");
    output.push_str("#include \"VectorGraphics/IconMetadata.h\"\n\n");
    output.push_str("namespace VectorGraphics {\n\n");
    
    // Generate SVG content constants - USE UNIQUE DELIMITER
    for icon in icons {
        let const_name = format!("ICON_SVG_{}", sanitize_identifier(&icon.id));
        // CORRECTION: Utiliser un dlimiteur unique qui ne peut pas apparatre dans le SVG
        output.push_str(&format!("static const char* {} = R\"SVGDATA({})SVGDATA\";\n\n", const_name, icon.svg_content));
    }
    
    // Generate color mappings arrays
    for icon in icons {
        if !icon.color_mappings.is_empty() {
            let array_name = format!("ICON_MAPPINGS_{}", sanitize_identifier(&icon.id));
            output.push_str(&format!("static const CompiledColorMapping {}[] = {{\n", array_name));
            
            for mapping in &icon.color_mappings {
                output.push_str("    {\n");
                output.push_str(&format!("        \"{}\",\n", mapping.element_id));
                output.push_str(&format!("        \"{}\",\n", mapping.property));
                output.push_str(&format!("        0x{:08X}u,\n", mapping.original_color));
                output.push_str(&format!("        \"{}\"\n", mapping.css_class));
                output.push_str("    },\n");
            }
            
            output.push_str("};\n\n");
        }
    }
    
    // Generate zone index arrays
    for icon in icons {
        for (zone_idx, zone) in icon.color_zones.iter().enumerate() {
            let array_name = format!(
                "ICON_ZONE_{}_INDICES_{}",
                sanitize_identifier(&icon.id),
                zone_idx
            );
            output.push_str(&format!("static const size_t {}[] = {{ ", array_name));
            
            for (i, idx) in zone.mapping_indices.iter().enumerate() {
                if i > 0 {
                    output.push_str(", ");
                }
                output.push_str(&format!("{}", idx));
            }
            
            output.push_str(" };\n");
        }
        
        if !icon.color_zones.is_empty() {
            output.push_str("\n");
        }
    }
    
    // Generate color zones arrays
    for icon in icons {
        if !icon.color_zones.is_empty() {
            let array_name = format!("ICON_ZONES_{}", sanitize_identifier(&icon.id));
            output.push_str(&format!("static const CompiledColorZone {}[] = {{\n", array_name));
            
            for (zone_idx, zone) in icon.color_zones.iter().enumerate() {
                let indices_array = format!(
                    "ICON_ZONE_{}_INDICES_{}",
                    sanitize_identifier(&icon.id),
                    zone_idx
                );
                
                output.push_str("    {\n");
                output.push_str(&format!("        0x{:08X}u,\n", zone.original_color));
                output.push_str(&format!("        \"{}\",\n", zone.default_token));
                output.push_str(&format!("        {},\n", indices_array));
                output.push_str(&format!("        {}\n", zone.mapping_indices.len()));
                output.push_str("    },\n");
            }
            
            output.push_str("};\n\n");
        }
    }
    
    // Generate main icons array
    output.push_str("static const CompiledIconData COMPILED_ICONS[] = {\n");
    
    for icon in icons.iter() {
        let svg_const = format!("ICON_SVG_{}", sanitize_identifier(&icon.id));
        let mappings_const = if !icon.color_mappings.is_empty() {
            format!("ICON_MAPPINGS_{}", sanitize_identifier(&icon.id))
        } else {
            "nullptr".to_string()
        };
        let zones_const = if !icon.color_zones.is_empty() {
            format!("ICON_ZONES_{}", sanitize_identifier(&icon.id))
        } else {
            "nullptr".to_string()
        };
        
        output.push_str("    {\n");
        output.push_str(&format!("        \"{}\",\n", icon.id));
        output.push_str(&format!("        {},\n", svg_const));
        output.push_str(&format!("        {:.2}f,\n", icon.width));
        output.push_str(&format!("        {:.2}f,\n", icon.height));
        output.push_str(&format!("        {},\n", mappings_const));
        output.push_str(&format!("        {},\n", icon.color_mappings.len()));
        output.push_str(&format!("        {},\n", zones_const));
        output.push_str(&format!("        {}\n", icon.color_zones.len()));
        output.push_str("    },\n");
    }
    
    output.push_str("};\n\n");
    output.push_str(&format!("static const size_t COMPILED_ICONS_COUNT = {};\n\n", icons.len()));
    output.push_str("} // namespace VectorGraphics\n");
    
    fs::write(output_path, output)
}

fn find_svg_files(dir: &Path) -> Vec<PathBuf> {
    let mut svg_files = Vec::new();
    
    if dir.is_dir() {
        if let Ok(entries) = fs::read_dir(dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.is_dir() {
                    svg_files.extend(find_svg_files(&path));
                } else if path.extension().and_then(|s| s.to_str()) == Some("svg") {
                    svg_files.push(path);
                }
            }
        }
    }
    
    svg_files
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    
    if args.len() != 3 {
        eprintln!("Usage: icon_compiler <icons_directory> <output_header>");
        std::process::exit(1);
    }
    
    let icons_dir = Path::new(&args[1]);
    let output_file = Path::new(&args[2]);
    
    if !icons_dir.exists() {
        eprintln!("Error: Icons directory does not exist: {:?}", icons_dir);
        std::process::exit(1);
    }
    
    let svg_files = find_svg_files(icons_dir);
    
    if svg_files.is_empty() {
        eprintln!("Warning: No SVG files found in {:?}", icons_dir);
        std::process::exit(0);
    }
    
    let mut icons = Vec::new();
    
    for svg_path in svg_files {
        match process_icon(&svg_path) {
            Ok(icon_data) => {
                println!("Processed {}: {} colors detected", 
                    icon_data.id, 
                    icon_data.color_mappings.len()
                );
                icons.push(icon_data);
            }
            Err(e) => {
                eprintln!("Warning: Failed to process \"{}\": {}", 
                    svg_path.display(), 
                    e
                );
            }
        }
    }
    
    if icons.is_empty() {
        eprintln!("Error: No icons were successfully processed");
        std::process::exit(1);
    }
    
    if let Err(e) = generate_header_file(&icons, output_file) {
        eprintln!("Error: Failed to generate header file: {}", e);
        std::process::exit(1);
    }
    
    println!("Generated icon data for {} icons", icons.len());
}